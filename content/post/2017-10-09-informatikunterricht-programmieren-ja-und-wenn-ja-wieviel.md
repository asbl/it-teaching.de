---
title: Informatikunterricht – Programmieren… ja und wenn ja wieviel?
author: a.sbl
type: post
date: "2017-10-09"

categories:
  - Informatik
  
tags:
  - Programmieren
  - Theorie
---
Im Informatikunterricht der Oberstufe (Hessen) ist es so, dass sich beim Programmieren die "Spreu vom Weizen trennt": Wer gerne programmiert und dies auch in seiner Freizeit tut, der ist auch im Unterricht erfolgreich. Wer nur die 2-3 Stunden gedanklich mit dem Programmieren auseinandersetzt und zu Hause nicht selbst programmiert, der wird im Laufe der Oberstufe nur Frustration sammeln. Dies ist deshalb schade, weil das Fach Informatik noch so viel mehr bietet als "nur" Programmieren. Entweder man kann beim Programmieren in die Tiefe gehen und sich immer mehr Modellierungstechniken aneignen, um komplexe Probleme zu lösen, oder man kann die Breite des Faches entdecken und z.B. die unterschiedlichsten Algorithmen entdecken um eine riesige Vielzahl von Problemstellungen kennenzulernen. 

So habe ich es schon erlebt, dass ein Kurs, der vorher beim Programmieren immer gemurrt hat plötzlich aufblühte, als es um die theoretische Analyse von Algorithmen ging. Dabei kam mir zwischenzeitlich der Gedanke, dass man sogar fast komplett auf das Programmieren verzichten könnte. Aber ist dies tatsächlich eine Option?

Die Informatik ist ein Fach, dass eine unglaubliche Bandbreite an Themen und Gebieten vorzuweisen hat. Wenn man Informatik unterrichtet muss man sich daher fragen: Was ist im Sinne der Vorbereitung auf das Studium und zur Selbstbewussten Teilnahme an einer digitalen Gesellschaft wichtiger? Den Schülern gute Programmierkenntnisse beibringen oder die ganze Bandbreite des Faches Informatik aufzeigen, um die Vielfältigkeit dieser Wissenschaft zu vermitteln?

Könnte man eines der Ziele des Informatikunterrichtes, Technik zu entmystifizieren nicht auch ohne Programmierung erreichen? Dann würde man viel Zeit gewinnen um Themen zu bearbeiten, die massiv zur Allgemeinbildung beitragen und die bis jetzt nur am Rande oder sogar gar nicht im Informatikunterricht in Hessen thematisiert werden, z.B. (Public Key-) Kryptographie, Data Mining, Machine Learning, Künstliche Intelligenz, Graphen, Bildverarbeitung.

## Ist Programmierung nötig?

Die erste Frage ist für mich inzwischen recht klar zu beantworten:

**Ja.**

Es gibt (mindestens) zwei Begründungsansätze für diese Antwort:

**Erstens: Programmieren fördert das algorithmische Denken und Problemlösen**

Programmieren ist ein Hilfsmittel um Probleme in zahlreichen Anwendungsgebieten zu lösen. Durch das Programmieren auch unser abstraktes Denken geschult, man lernt komplexe Situationen zu modellieren, Probleme zu zerlegen und in eine für einen Computer verständliche Sprache zu übersetzen. 

Das Programmieren ist eine wichtige Säule, um "Computational Thinking" (im deutschen algorithmisches Denken, Modellierung und Problemlösen) zu fördern. Dies ist eine wichtige Fähigkeit, die die Schüler später in viele Awendungsbereiche auch außerhalb der Informatik mitnehmen können, da die Schnittmenge vieler Wissenschaften zur Informatik immer größer wird. 

Vor allem Datenanalyse und Verarbeitung sind Fähigkeiten, die man später in fast jedem Anwendungsgebiet gut gebrauchen kann. Man könnte daher sogar so weit gehen und fragen, ob Programmieren nicht sogar eine Fähigkeit ist, die jeder Schüler mit allgemeiner Hochschulreife zu einem gewissen Level beherrschen sollte.

**Zweitens: Man wird zum Tool Creator**

Gerade im Zuge der Digitalisierung werden viele Schüler zu "Tool Usern" erzogen. Zahlreiche Tools werden benutzt und man kann sich nur im Rahmen der Möglichkeiten bewegen, die einem die Besitzer dieser Tools zuschreiben. Man lebt innerhalb der Ökosysteme von Apple, Microsoft & co und erlebt die digitalisierte Welt gefiltert durch die Möglichkeiten, die diese Ökosysteme und Apps in diesen Ökosystemen mitbringen.

Nur durch Programmieren kann man den Weg vom Tool User zum Tool Creator gehen, d.h. man kann eigene Tools erschaffen. Auf diese Weise werden die Möglichkeiten, die einem Tools bieten erweitert um theoretisch alles, was die eigene Vorstellung und Phantasie zulässt.

**Drittens: Programmieren hilft dabei die (informatische) Welt zu verstehen**

Seit der Softwarekrise in den 70er Jahren hat sich verändert, was man unter dem Begriff Programmieren versteht. Programmieren bedeutet zunehmend "komplexe" Probleme im Team lösen. Natürlicher Bestandteil dieser Problemlöseprozesse sind Modellierungstechniken, aber auch Strukturen und Haltungen (Stichwort "Agilität"). 

Man könnte soweit gehen und sagen: Der Kern des informatischen Problemlösens ist das Lösen von wirklich komplexen Problemen. Komplexe Softwaresysteme haben eine so umfangreiche Code-Basis, dass kein Mensch gleichzeitig das komplette System bis in das Detail hinein überblicken und verstehen kann. Nichts was der Mensch geschaffen hat ist so komplex wie moderne Software. Programmieren ist demnach die Tätigkeit. 

Schüler werden diese Komplexität natürlich nicht selbst erleben können. Aber beim Programmieren können zahlreiche Aspekte erfahren werden,die das Grundproblem -den Umgang mit Komplexität- und Lösungsstrategien erfahrbar machen: Modellieren, Agile Entwicklung, Verwendung von Bibliotheken, Arbeiten mit Schnittstellen und Dokumentationen und vieles mehr.

## Wie gut sollte ein Schüler am Ende seiner Schullaufbahn programmieren können? 

Die Frage ist schon sehr viel schwieriger zu beantworten: 

Ich finde die Frage kann man so beantworten: Ein Schüler sollte so viel programmieren können, dass er später in der Lage ist eigenständig alle Arten kleinere Arten von Problemen lösen kann und gleichzeitig ein Verständnis dafür entwickelt, wie "Programmieren im Großen" funktioniert. 

  * Schleifen
  * Verzweigungen
  * Funktionen
  * Verwendung von Bibliotheken
  * Höhere Datenstrukturen wie Listen oder dynamische Arrays
  * Objektorientiertes Programmieren
  * Aufwandsabschätzung bei Algorithmen

Wichtiger als das erstellen von komplexen Informatiksystemen ist meiner Meinung nach das Umgehen mit Daten. Schüler sollten in der Lage sein, Daten aus Dateien (z.B. csv Dateien) und Datenbanken auszulesen und in irgendeiner Form zu verarbeiten. Wenn man die oben genannten Grundtechniken beherrscht sind damit die Möglichkeiten prinzipiell unbeschränkt.

### Exkurs: Ist Objektorientierung notwendig
  
_Ich habe übrigens lange überlegt, ob ich die Objektorientierung in die Liste mit aufnehmen soll: Prinzipiell kann man in der richtigen Sprache guten Code schreiben, ohne objektorientiert zu programmieren. Erst wenn man in größeren Teams arbeitet und gezwungen ist Schnittstellen zu definieren, nimmt die Bedeutung dieses Paradigmas zu._  

  * _Objektorientierung ist ein schweres Konzept: Wer in der Schule gelernt hat ein Klassendiagramm für eine Anwendungssituation zu modellieren, der ist noch weit davon entfernt gut objektorientiert zu programmieren. Es gibt hier so viele Irrwege bei denen man sich verrennen kann und der Unterricht kann es kaum leisten, Programmierer auszubilden, die gut objektorientiert programmieren können. Insbesondere ist es hier notwendig an wirklich großen Projekten zu arbeiten und Best Practice Ansätze (Entwurfsmuster) zu studieren._  
  
  * _Auf der anderen Seite ist ein grundlegendes Verständnis von Objektorientierung notwendig um Lösungsansätze zu verstehen und oft auch Bibliotheken in der Programmiersprache zu verwenden. &nbsp;_  

_Meiner Meinung ist es daher ausreichend, wenn der Unterricht sich hier auf die Grundlagen der objektorientierten Programmierung lehrt und die Tiefen der objektorientierten Modellierung nur dann erkundet, wenn ausreichend Zeit dafür gegeben ist. Wichtig ist vor allem Objektorientierung nicht als DIE Lösung für informatische Probleme darzustellen, sondern auch andere Wege Probleme zu strukturieren, daneben zu stellen._ 

## Wie sollte Programmierung gelehrt werden?

Prinzipiell gibt es sehr unterschiedliche Ansätze das Programmieren zu unterrichten:

**Lernen durch Anwendungen**

Dieser Ansatz versucht mit Hilfe von spielerischer Umgebungen wie&nbsp;[GameGrid][1],&nbsp;[Greenfoot][2]&nbsp;oder dem Programmieren von IDEs mit integrierten GUI-Erzeugern wie z.B. dem&nbsp;[Java-Editor][3]&nbsp;den Spaß am Programmieren zu fördern.

Das Problem bei diesem Ansatz: Dadurch, dass man gleichzeitig sowohl mit imperativen Sprachelementen und mit Klassen und Objekten arbeiten muss, müssen die Schüler sehr viele Sprachkonstrukte gleichzeitig lernen. Manchmal führt kein Weg daran vorbei Sprachelemente erst einmal zu nutzen und später genauer zu verstehen.

Unbestritten ist aber der Vorteil dieser Ansätze: Wenn man schnell Ergebnisse produziert, dann macht Programmieren Spaß!

**Lernen durch Konzepte**

Dieser Ansatz setzt die Programmierkonzepte in den Vordergrund. Man verzichtet auf optisch ansprechende Anwendungen zugunsten einer Fokussierung auf Sprachkonstrukte. Es reicht dann, die Ausgabe auf eine Kommandozeile auszugeben.

Die Gegner dieses Ansatzes argumentieren damit, dass dieser wenig motivierend ist (so z.B. mein Ausbilder). Dafür ist für die Schüler klar nachvollziehbar, was gerade passiert, die Schüler lernen ein Konzept nach dem Anderen. Dieser Ansatz ist weniger motivierend, dafür aber verständnisfördernd.

**Reduzierte Programmierumgebungen**

Darüber hinaus gibt es noch Konzepte wie LOGO bzw. Turtlegrafik oder Robotersimulationen (Hamstersimulator, Kara,&#8230;), die reduzierte Umgebungen zur Verfügung stellen, oft in Kombination mit grafischer Programmierung.

Das schöne an diesem Ansatz ist, dass hier die grundlegenden Programmierkonzepte gelernt werden können und gleichzeitig Ergebnisse sichtbar sind.

Diese Ansätze kombinieren Vorzüge aus den ersten beiden Beispielen. Der Fokus liegt hier oft stärker auf der imperativen Programmierung

**Beurteilung der Ansätze**

Prinzipiell konnte ich in den ersten Jahren folgendes feststellen: Es gibt einige Schüler, die mit guten Vorerfahrungen in den Unterricht kommen. Diese Schüler werden zwar später gute Programmierer, lernen im Unterricht selbst aber wenig. Weiterhin gibt es Schüler, die ohne Vorerfahrungen in den Unterricht kommen und mit dem algorithmischen Denken überhaupt nicht klar kommen. Diese Schüler lernen auch wenig. Zuletzt gibt es noch Schüler, die mit keiner oder wenig Programmiererfahrungen starten, für die der Unterricht der erste Baustein für eine Programmierkarriere ist. Dies ist die Zielgruppe, die ein guter Programmiersprachenunterricht erreichen muss. Um diese Schüler zu erreichen ist es sowohl nötig zu motivieren als auch auf eine strukturierte Weise in das algorithmische Denken einzuführen. Im Gegensatz zu den anderen Fragen, finde ich hier noch keine klare Antwort, sondern muss aus meinen Erfahrungen im Unterricht schöpfen: 

**Delphi**

Die ersten Erfahrungen mit Delphi/Lazarus sind zwiespaltigen: Auf der einen Seite ist Pascal als Sprache sehr gut zu lernen. Auf der anderen Seite ist die Anwendungsferne (Wer programmiert noch in Delphi?) ein großer Motivationsblocker. Zudem empfand ich es als schwierig, das man durch den Fokus auf den GUI-Builder direkt in die objektorientierte Programmierung einsteigen muss und gleichzeitig imperative Programmstrukturen lehren muss. Das ist zwar Motivationsfördernd, macht den Einstieg für Anfänger aber unnötig schwer.

Im zweiten Durchlauf habe ich vor Delphi Turtle-Grafik mit Pascal vorgeschaltet. Dieser Ansatz war schon deutlich zielführender.

**Greenfoot**

Nachdem ich jetzt ein Jahr komplett mit Greenfoot gearbeitet habe, muss ich feststellen, dass ich mit dem diesem Ansatz nicht glücklich geworden bin. Die Schüler mit Vorerfahrungen haben hier zwar tolle Sachen gemacht. Ich hatte aber das Gefühl, dass gerade die Schüler, die Schwierigkeiten beim Programmieren hatten, es einfacher gehabt hätten, wenn sich der Unterricht auf die wesentlichen Konzepte beschränkt hätte. Diese Schüler brauchten eine klare Struktur. Man beginnt irgendwie gleichzeitig mit Objektorientierung und imperativer Programmierung, braucht schnell Konstrukte, die die Schüler zu diesem Zeitpunkt noch nicht verstehen können, so dass ihnen der klare rote Faden fehlt. 

**Python**

Aus Frustration über die ersten Jahre mit Delphi/Java habe ich im letzten Jahr ausprobiert und Python als erste Programmiersprache verwendet.

Die Idee war folgende: Dadurch, dass sich hier auf eine winzige Anzahl an Konzepten konzentriert werden kann, soll vor allem die Verwendung dieser Konzepte zum Problemlösen in unterschiedlichen Bereichen im Vordergrund stehen. 

Ich bin dabei zweigleisig gefahren:

  * Damit die Schüler strukturiert ein Thema nach dem anderen Lernen, habe ich einen Onlinekurs erstellt (https://stepik.org/course/6229/). Im Programmierkurs werden die Konzepte isoliert voneinander behandelt. Da die Umgebung nur textbasierte Aufgaben zulässt, dient der Kurs sozusagen als Fingerübung das Programmieren und algorithmische Denken zu fördern.
  * Im Unterricht habe ich mit Turtle-Grafik begonnen und habe nebenbei immer wieder interessante Anwendungen der Programmiersprache betrachtet (Spieleentwicklung mit pygame-zero oder gamgegridp, Textadventures, das nächste mal soll auf jeden Fall auch Datanalyse mit Pandas und mathplotlib ein Thema sein). Der Unterricht dient also stärker dazu zu motivieren und Anwendungen aufzuzeigen.

Mit dieser Strategie bin ich bisher am zufriedensten und werde diese weiter verfolgen.

Ob dies der &#8220;goldene Weg&#8221; ist, ist natürlich vollkommen offen. Die grundlegenden Fragen &#8220;Wie viel Programmierung braucht der Schüler und wie führt man diese am besten ein?&#8221; werden mich auf jeden Fall noch eine ganze Zeit lang beschäftigen. Ich bin gespannt, wohin mich diese Überlegung in den nächsten Jahren führen und wie dies meinen Unterricht beeinflussen wird.

Letzte Bearbeitung: 06.01.2019 &#8211; Da dies einer der meistgelesenen Artikel auf dem Blog ist, aktualisiere ich diesen gelegentlich, da sich auch meine Gedanken zu dem Thema ändern. Ich habe jetzt auch das Gefühl die Fragestellung nur im Ansatz angekratzt zu haben und daher werde ich den Text sicherlich noch das ein oder andere mal umformulieren, bis ich mit der Form zufrieden bin.

 [1]: http://www.java-online.ch/gamegrid/index.php
 [2]: https://www.greenfoot.org/door
 [3]: http://javaeditor.org/doku.php